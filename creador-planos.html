<!DOCTYPE html>
<html lang="es">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>Dibuja planos con cotas</title>
<style>
:root{--bg:#f6f7fb;--accent:#0b5fff;--muted:#666;--cota:#000000;--danger:#dc3545;--success:#28a745;--warning:#ffc107;--info:#17a2b8}
html,body{height:100%;margin:0;font-family:Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial}
.app{display:flex;flex-direction:column;height:100vh;padding:12px;gap:12px;background:var(--bg)}
.top{display:flex;gap:12px;align-items:center}
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center}
label{font-size:14px;color:var(--muted)}
input[type=range]{width:140px}
input[type=number]{width:60px;padding:4px;border:1px solid #ddd;border-radius:4px}
select{padding:4px}
button{background:var(--accent);color:white;border:none;padding:8px 12px;border-radius:8px;cursor:pointer}
button.ghost{background:transparent;color:var(--muted);border:1px solid #ddd}
button.secondary{background:#444}
button.danger{background:var(--danger)}
button.success{background:var(--success)}
button.warning{background:var(--warning)}
button.info{background:var(--info)}
.canvas-wrap{flex:1;display:flex;align-items:center;justify-content:center;position:relative}
canvas{background:white;border-radius:8px;box-shadow:0 6px 18px rgba(10,10,20,0.08);max-width:100%;height:auto}
.help{font-size:13px;color:var(--muted)}
.small{font-size:13px;color:var(--muted)}
.footer{display:flex;justify-content:space-between;align-items:center}
.menuCota{position:absolute;background:white;border:1px solid #ccc;padding:6px;border-radius:6px;display:none;}
.menuCota button{margin:2px;padding:4px 8px;font-size:12px;}
.file-input{display:none;}
.text-dialog{position:absolute;background:white;border:1px solid #ccc;padding:12px;border-radius:8px;box-shadow:0 4px 12px rgba(0,0,0,0.1);display:none;z-index:100;}
.text-dialog input{width:200px;padding:8px;border:1px solid #ddd;border-radius:4px;margin-bottom:8px;}
.text-dialog button{margin:2px;padding:4px 8px;}
.help-text{font-size:12px;color:var(--muted);margin-top:5px;}
</style>
</head>
<body>
<div class="app">
<div class="top">
<div style="font-weight:700;font-size:18px">Dibuja planos (con cotas)</div>
<div style="flex:1"></div>
<div class="controls">
<label>Columnas: <span id="colsLabel">20</span></label>
<input id="cols" type="range" min="8" max="48" value="20">
<input id="colsInput" type="number" min="8" max="48" value="20">
<label>Filas: <span id="rowsLabel">20</span></label>
<input id="rows" type="range" min="8" max="48" value="20">
<input id="rowsInput" type="number" min="8" max="48" value="20">
<label>Tamaño punto: <span id="dotLabel">6</span>px</label>
<input id="dotSize" type="range" min="3" max="12" value="6">

<label>Escala:</label>
<select id="scaleSelect">
  <option value="0.5">0.5 cm</option>
  <option value="1" selected="">1 cm</option>
  <option value="2">2 cm</option>
</select>

<label>Tamaño texto: </label>
<select id="fontSize">
  <option value="12">12px</option>
  <option value="14">14px</option>
  <option value="16" selected>16px</option>
  <option value="18">18px</option>
  <option value="20">20px</option>
  <option value="24">24px</option>
  <option value="28">28px</option>
  <option value="32">32px</option>
</select>

<button id="undo" class="ghost">Deshacer</button>
<button id="redo" class="ghost">Rehacer</button>
<button id="clear" class="ghost">Borrar todo</button>
<button id="toggleCota" class="secondary">Modo cota: OFF</button>
<button id="toggleEraser" class="danger">Modo borrado: OFF</button>
<button id="toggleText" class="warning">Modo texto: OFF</button>
<button id="saveProject" class="success">Guardar proyecto</button>
<button id="loadProject">Cargar proyecto</button>
<input type="file" id="fileInput" class="file-input" accept=".json">
<button id="download">Descargar PDF</button>
<button id="exportDXF" class="info">Exportar DXF</button>
</div>
</div>
<div class="canvas-wrap">
<canvas id="board" width="900" height="900" aria-label="Tablero de dibujo por puntos" style="width: 900px; height: 900px;"></canvas>
<div id="menuCota" class="menuCota">
<button data-pos="arriba">Arriba</button>
<button data-pos="abajo">Abajo</button>
<button data-pos="izquierda">Izquierda</button>
<button data-pos="derecha">Derecha</button>
</div>
<div id="textDialog" class="text-dialog">
  <input type="text" id="textInput" placeholder="Escribe tu texto aquí">
  <div>
    <button id="confirmText">Aceptar</button>
    <button id="cancelText" class="ghost">Cancelar</button>
  </div>
</div>
</div>
<div class="footer">
<div class="help">Modo cota: elige dos puntos y selecciona la posición de la cota.</div>
<div class="small">Exporta en PDF a escala real. <strong>Haz clic derecho para reiniciar el punto de inicio.</strong></div>
</div>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/jspdf/2.5.1/jspdf.umd.min.js"></script>
<script>
const canvas = document.getElementById('board');
const ctx = canvas.getContext('2d');
const menuCota = document.getElementById('menuCota');
const fileInput = document.getElementById('fileInput');
const textDialog = document.getElementById('textDialog');
const textInput = document.getElementById('textInput');
const confirmText = document.getElementById('confirmText');
const cancelText = document.getElementById('cancelText');
let cols=20, rows=20, dotSize=6;
let points=[], lines=[], cotas=[], textos=[];
let cotaMode=false, cotaFirst=null;
let eraseMode=false;
let textMode=false;
let lastIdx=null;
let unitCM;              
let scaleCM = 1;
const cotaOffset=50;     
const flechaSize=3;      

// Historial para deshacer/rehacer
let history = [];
let historyIndex = -1;
let redoStack = [];

// Para el modo texto
let textPosition = null;
let currentFontSize = 16;

function fixDPI(){
  const ratio=window.devicePixelRatio||1;
  const w=canvas.width; const h=canvas.height;
  canvas.width=w*ratio; canvas.height=h*ratio;
  canvas.style.width=w+'px'; canvas.style.height=h+'px';
  ctx.setTransform(ratio,0,0,ratio,0,0);
}

function rebuildPoints(){
  points=[];
  const width=parseInt(canvas.style.width);
  const height=parseInt(canvas.style.height);
  const cellW=width/(cols-1);
  const cellH=height/(rows-1);

  unitCM = cellW / scaleCM;

  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      points.push({x:Math.round(c*cellW), y:Math.round(r*cellH)});
    }
  }
}

function drawGrid(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle='#fff'; ctx.fillRect(0,0,canvas.width,canvas.height);

  // dibujar líneas de cuadrícula
  ctx.strokeStyle='#eee';
  ctx.lineWidth=1;
  const cellW = points[1].x - points[0].x;
  const cellH = points[cols].y - points[0].y;
  for(let r=0;r<rows;r++){
    ctx.beginPath();
    ctx.moveTo(points[r*cols].x, points[r*cols].y);
    ctx.lineTo(points[r*cols + (cols-1)].x, points[r*cols + (cols-1)].y);
    ctx.stroke();
  }
  for(let c=0;c<cols;c++){
    ctx.beginPath();
    ctx.moveTo(points[c].x, points[c].y);
    ctx.lineTo(points[(rows-1)*cols + c].x, points[(rows-1)*cols + c].y);
    ctx.stroke();
  }

  // dibujar líneas de usuario
  ctx.strokeStyle='#006400';
  ctx.lineWidth=4;
  lines.forEach(ln=>{
    const A=points[ln.a], B=points[ln.b];
    ctx.beginPath(); ctx.moveTo(A.x,A.y); ctx.lineTo(B.x,B.y); ctx.stroke();
  });

  // dibujar cotas
  cotas.forEach(ct=>drawCota(ctx,ct));

  // dibujar textos
  textos.forEach(txt=>{
    ctx.font = `${txt.fontSize}px sans-serif`;
    ctx.fillStyle = '#000';
    ctx.fillText(txt.texto, txt.x, txt.y);
  });

  // dibujar puntos
  points.forEach(p=>{
    ctx.beginPath();
    ctx.fillStyle='#0b5fff';
    ctx.arc(p.x,p.y,dotSize,0,Math.PI*2);
    ctx.fill();
  });

  // Dibujar punto de inicio actual si existe
  if (lastIdx !== null && !cotaMode && !eraseMode && !textMode) {
    const p = points[lastIdx];
    ctx.beginPath();
    ctx.fillStyle='#ff0000';
    ctx.arc(p.x, p.y, dotSize * 1.5, 0, Math.PI * 2);
    ctx.fill();
  }
}

function nearestPoint(x,y){
  let best=null,bestDist=Infinity;
  points.forEach((p,i)=>{
    const d=(p.x-x)**2+(p.y-y)**2;
    if(d<bestDist){ bestDist=d; best=i; }
  });
  const width=parseInt(canvas.style.width), height=parseInt(canvas.style.height);
  const threshold=Math.max(width/(cols-1),height/(rows-1))*0.6;
  return bestDist<=threshold**2?best:null;
}

function saveState() {
  redoStack = [];
  document.getElementById('redo').disabled = true;
  
  historyIndex++;
  history[historyIndex] = {
    lines: JSON.parse(JSON.stringify(lines)),
    cotas: JSON.parse(JSON.stringify(cotas)),
    textos: JSON.parse(JSON.stringify(textos))
  };
  
  if (history.length > 100) {
    history.shift();
    historyIndex--;
  }
}

function eraseElementAt(x, y) {
  const idx = nearestPoint(x, y);
  if (idx === null) return;
  
  saveState();
  
  const linesToRemove = lines.filter(line => line.a === idx || line.b === idx);
  lines = lines.filter(line => !linesToRemove.includes(line));
  
  const cotasToRemove = cotas.filter(cota => cota.a === idx || cota.b === idx);
  cotas = cotas.filter(cota => !cotasToRemove.includes(cota));
  
  const textosToRemove = textos.filter(txt => {
    const dx = txt.x - x;
    const dy = txt.y - y;
    return Math.sqrt(dx*dx + dy*dy) < 30;
  });
  textos = textos.filter(txt => !textosToRemove.includes(txt));
  
  drawGrid();
}

function resetLastPoint() {
  lastIdx = null;
  drawGrid();
}

canvas.addEventListener('click',ev=>{
  if (ev.button !== 0) return;
  
  const rect=canvas.getBoundingClientRect();
  const pos={x:ev.clientX-rect.left,y:ev.clientY-rect.top};
  
  if (eraseMode) {
    eraseElementAt(pos.x, pos.y);
    return;
  }
  
  if (textMode) {
    saveState();
    textPosition = pos;
    textDialog.style.display = 'block';
    textDialog.style.left = ev.clientX + 'px';
    textDialog.style.top = ev.clientY + 'px';
    textInput.value = '';
    textInput.focus();
    return;
  }
  
  const idx=nearestPoint(pos.x,pos.y);
  if(idx===null) return;
  if(cotaMode){
    if(cotaFirst===null){ 
      cotaFirst=idx; 
    } else {
      // Permitir cualquier combinación de puntos, no solo los alineados
      menuCota.style.left=ev.clientX+'px';
      menuCota.style.top=ev.clientY+'px';
      menuCota.style.display='block';
      menuCota.dataset.a=cotaFirst; 
      menuCota.dataset.b=idx;
    }
  } else {
    if(lastIdx===null) {
      lastIdx=idx;
      drawGrid();
    } else if(idx!==lastIdx){ 
      saveState();
      lines.push({a:lastIdx,b:idx}); 
      lastIdx=idx; 
      drawGrid(); 
    }
  }
});

canvas.addEventListener('contextmenu', function(ev) {
  ev.preventDefault();
  
  if (!cotaMode && !eraseMode && !textMode) {
    resetLastPoint();
    return false;
  }
});

confirmText.addEventListener('click', () => {
  if (textInput.value.trim() !== '' && textPosition) {
    textos.push({
      texto: textInput.value,
      x: textPosition.x,
      y: textPosition.y,
      fontSize: currentFontSize
    });
    textDialog.style.display = 'none';
    drawGrid();
  }
});

cancelText.addEventListener('click', () => {
  textDialog.style.display = 'none';
  undo();
});

menuCota.querySelectorAll('button').forEach(b=>{
  b.addEventListener('click',()=>{
    saveState();
    const a=parseInt(menuCota.dataset.a), bIdx=parseInt(menuCota.dataset.b);
    cotas.push({a:a, b:bIdx, pos:b.dataset.pos});
    cotaFirst=null; 
    menuCota.style.display='none'; 
    drawGrid();
  });
});

function drawCota(ctx,ct){
  const A=points[ct.a], B=points[ct.b];
  ctx.strokeStyle='#000'; 
  ctx.fillStyle='#000'; 
  ctx.lineWidth=1.5; 
  ctx.font='12px sans-serif';
  
  // Determinar si la cota es horizontal o vertical basándose en la posición seleccionada
  if(ct.pos === 'arriba' || ct.pos === 'abajo') {
    // Cota horizontal - las líneas auxiliares son verticales
    const y = ct.pos === 'arriba' ? Math.min(A.y, B.y) - cotaOffset : Math.max(A.y, B.y) + cotaOffset;
    
    // Líneas auxiliares verticales desde los puntos exactos
    ctx.beginPath(); 
    ctx.moveTo(A.x, A.y); 
    ctx.lineTo(A.x, y); 
    ctx.moveTo(B.x, B.y); 
    ctx.lineTo(B.x, y); 
    ctx.stroke();
    
    // Línea de cota principal horizontal
    ctx.beginPath(); 
    ctx.moveTo(A.x, y); 
    ctx.lineTo(B.x, y); 
    ctx.stroke();
    
    // Flechas
    drawFlecha(ctx, A.x, y, 'H', false); 
    drawFlecha(ctx, B.x, y, 'H', true);
    
    // Texto de la cota (en milímetros)
    const distMM = Math.abs(B.x - A.x) / unitCM * scaleCM * 10;
    ctx.fillText(distMM.toFixed(0), (A.x + B.x) / 2, y - 5);
    
  } else {
    // Cota vertical - las líneas auxiliares son horizontales
    const x = ct.pos === 'izquierda' ? Math.min(A.x, B.x) - cotaOffset : Math.max(A.x, B.x) + cotaOffset;
    
    // Líneas auxiliares horizontales desde los puntos exactos
    ctx.beginPath(); 
    ctx.moveTo(A.x, A.y); 
    ctx.lineTo(x, A.y); 
    ctx.moveTo(B.x, B.y); 
    ctx.lineTo(x, B.y); 
    ctx.stroke();
    
    // Línea de cota principal vertical
    ctx.beginPath(); 
    ctx.moveTo(x, A.y); 
    ctx.lineTo(x, B.y); 
    ctx.stroke();
    
    // Flechas
    drawFlecha(ctx, x, A.y, 'V', 'top');
    drawFlecha(ctx, x, B.y, 'V', 'bottom');
    
    // Texto de la cota (en milímetros)
    const distMM = Math.abs(B.y - A.y) / unitCM * scaleCM * 10;
    ctx.save(); 
    ctx.translate(x - 7, (A.y + B.y) / 2); 
    ctx.rotate(-Math.PI / 2); 
    ctx.fillText(distMM.toFixed(0), 0, 0); 
    ctx.restore();
  }
}

function drawFlecha(ctx,x,y,dir,position){
  ctx.beginPath(); 
  const size=flechaSize;
  
  if(dir==='H'){ 
    if(position === true){
      ctx.moveTo(x-size,y-size);
      ctx.lineTo(x,y);
      ctx.lineTo(x-size,y+size);
    } else {
      ctx.moveTo(x+size,y-size);
      ctx.lineTo(x,y);
      ctx.lineTo(x+size,y+size);
    }
  } else { 
    if(position === 'top'){
      ctx.moveTo(x-size,y+size);
      ctx.lineTo(x,y);
      ctx.lineTo(x+size,y+size);
    } else {
      ctx.moveTo(x-size,y-size);
      ctx.lineTo(x,y);
      ctx.lineTo(x+size,y-size);
    }
  }
  ctx.stroke();
}

function undo() {
  if (historyIndex <= 0) return;
  
  redoStack.push({
    lines: JSON.parse(JSON.stringify(lines)),
    cotas: JSON.parse(JSON.stringify(cotas)),
    textos: JSON.parse(JSON.stringify(textos))
  });
  document.getElementById('redo').disabled = false;
  
  historyIndex--;
  const previousState = history[historyIndex];
  lines = JSON.parse(JSON.stringify(previousState.lines));
  cotas = JSON.parse(JSON.stringify(previousState.cotas));
  textos = JSON.parse(JSON.stringify(previousState.textos));
  
  drawGrid();
}

function redo() {
  if (redoStack.length === 0) return;
  
  historyIndex++;
  history[historyIndex] = {
    lines: JSON.parse(JSON.stringify(lines)),
    cotas: JSON.parse(JSON.stringify(cotas)),
    textos: JSON.parse(JSON.stringify(textos))
  };
  
  const nextState = redoStack.pop();
  lines = JSON.parse(JSON.stringify(nextState.lines));
  cotas = JSON.parse(JSON.stringify(nextState.cotas));
  textos = JSON.parse(JSON.stringify(nextState.textos));
  
  if (redoStack.length === 0) {
    document.getElementById('redo').disabled = true;
  }
  
  drawGrid();
}

function saveProject() {
  const projectData = {
    lines: lines,
    cotas: cotas,
    textos: textos,
    cols: cols,
    rows: rows,
    dotSize: dotSize,
    scaleCM: scaleCM
  };
  
  const dataStr = JSON.stringify(projectData);
  const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
  
  const exportFileDefaultName = 'proyecto-planos.json';
  
  const linkElement = document.createElement('a');
  linkElement.setAttribute('href', dataUri);
  linkElement.setAttribute('download', exportFileDefaultName);
  linkElement.click();
}

function loadProject() {
  fileInput.click();
}

function handleProjectFile(e) {
  const file = e.target.files[0];
  if (!file) return;
  
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const projectData = JSON.parse(e.target.result);
      
      if (!projectData.lines || !projectData.cotas || !projectData.cols || !projectData.rows) {
        throw new Error("Formato de archivo inválido");
      }
      
      saveState();
      
      lines = projectData.lines;
      cotas = projectData.cotas;
      textos = projectData.textos || [];
      cols = projectData.cols;
      rows = projectData.rows;
      dotSize = projectData.dotSize || 6;
      scaleCM = projectData.scaleCM || 1;
      
      document.getElementById('cols').value = cols;
      document.getElementById('colsInput').value = cols;
      document.getElementById('colsLabel').textContent = cols;
      
      document.getElementById('rows').value = rows;
      document.getElementById('rowsInput').value = rows;
      document.getElementById('rowsLabel').textContent = rows;
      
      document.getElementById('dotSize').value = dotSize;
      document.getElementById('dotLabel').textContent = dotSize;
      
      document.getElementById('scaleSelect').value = scaleCM;
      
      rebuildPoints();
      drawGrid();
      
      alert('Proyecto cargado correctamente');
    } catch (error) {
      console.error(error);
      alert('Error al cargar el proyecto: ' + error.message);
    }
  };
  reader.readAsText(file);
  
  e.target.value = '';
}

function generateDXF() {
  let dxfContent = `0
SECTION
2
HEADER
9
$ACADVER
1
AC1015
0
ENDSEC
0
SECTION
2
ENTITIES
`;

  const width = parseInt(canvas.style.width);
  const height = parseInt(canvas.style.height);
  
  const toWorldCoords = (x, y) => {
    const worldX = (x / width) * (cols-1) * scaleCM * 10;
    const worldY = (rows-1) * scaleCM * 10 - (y / height) * (rows-1) * scaleCM * 10;
    return { x: worldX, y: worldY };
  };

  lines.forEach(ln => {
    const A = points[ln.a];
    const B = points[ln.b];
    const worldA = toWorldCoords(A.x, A.y);
    const worldB = toWorldCoords(B.x, B.y);
    
    dxfContent += `0
LINE
8
0
10
${worldA.x.toFixed(2)}
20
${worldA.y.toFixed(2)}
30
0.0
11
${worldB.x.toFixed(2)}
21
${worldB.y.toFixed(2)}
31
0.0
`;
  });

  textos.forEach((txt, index) => {
    const worldPos = toWorldCoords(txt.x, txt.y);
    const textHeight = (txt.fontSize / 16) * 2.5;
    
    dxfContent += `0
TEXT
8
0
10
${worldPos.x.toFixed(2)}
20
${worldPos.y.toFixed(2)}
30
0.0
40
${textHeight.toFixed(2)}
1
${txt.texto}
7
STANDARD
50
0.0
`;
  });

  dxfContent += `0
ENDSEC
0
EOF
`;

  return dxfContent;
}

function exportToDXF() {
  const dxfContent = generateDXF();
  const blob = new Blob([dxfContent], { type: 'application/dxf' });
  const url = URL.createObjectURL(blob);
  
  const link = document.createElement('a');
  link.href = url;
  link.download = 'dibujo-planos.dxf';
  link.click();
  
  setTimeout(() => URL.revokeObjectURL(url), 100);
}

// CORRECCIÓN: Función exportToPDF mejorada
function exportToPDF() {
  const { jsPDF } = window.jspdf;
  const pdf = new jsPDF({unit:'mm',format:'a4',orientation:'landscape'});
  const startX=20, startY=20, step=10*scaleCM;

  // puntos
  for(let r=0;r<rows;r++){
    for(let c=0;c<cols;c++){
      pdf.circle(startX+c*step,startY+r*step,0.5,'F');
    }
  }

  // líneas
  lines.forEach(ln=>{
    const A={x:startX+(ln.a%cols)*step, y:startY+Math.floor(ln.a/cols)*step};
    const B={x:startX+(ln.b%cols)*step, y:startY+Math.floor(ln.b/cols)*step};
    pdf.setDrawColor(0,100,0);
    pdf.setLineWidth(1.6);
    pdf.line(A.x,A.y,B.x,B.y);
  });

  // CORRECCIÓN: Cotas con la misma lógica que en el canvas
  cotas.forEach(ct=>{
    const A={x:startX+(ct.a%cols)*step, y:startY+Math.floor(ct.a/cols)*step};
    const B={x:startX+(ct.b%cols)*step, y:startY+Math.floor(ct.b/cols)*step};
    pdf.setDrawColor(0,0,0); pdf.setTextColor(0,0,0); pdf.setLineWidth(0.8); pdf.setFontSize(10);
    const arrowSize=2; // Tamaño de flecha en mm

    if(ct.pos === 'arriba' || ct.pos === 'abajo') {
      // Cota horizontal
      const offset = 8.5; // 8.5mm de offset (equivalente a cotaOffset)
      const y = ct.pos === 'arriba' ? Math.min(A.y, B.y) - offset : Math.max(A.y, B.y) + offset;
      
      // Líneas auxiliares
      pdf.line(A.x, A.y, A.x, y);
      pdf.line(B.x, B.y, B.x, y);
      
      // Línea de cota principal
      pdf.line(A.x, y, B.x, y);
      
      // Flechas
      pdf.line(A.x+arrowSize, y-arrowSize, A.x, y);
      pdf.line(A.x+arrowSize, y+arrowSize, A.x, y);
      pdf.line(B.x-arrowSize, y-arrowSize, B.x, y);
      pdf.line(B.x-arrowSize, y+arrowSize, B.x, y);
      
      // Texto en mm
      const distMM = Math.abs(B.x - A.x) / step * scaleCM * 10;
      pdf.text(distMM.toFixed(0), (A.x + B.x) / 2, y - 2, 'center');
      
    } else {
      // Cota vertical - CORRECCIÓN IMPORTANTE
      const offset = 8.5; // 8.5mm de offset (equivalente a cotaOffset)
      const x = ct.pos === 'izquierda' ? Math.min(A.x, B.x) - offset : Math.max(A.x, B.x) + offset;
      
      // Líneas auxiliares
      pdf.line(A.x, A.y, x, A.y);
      pdf.line(B.x, B.y, x, B.y);
      
      // Línea de cota principal
      pdf.line(x, A.y, x, B.y);
      
      // Flechas (corregidas para orientación correcta)
      pdf.line(x-arrowSize, A.y+arrowSize, x, A.y);
      pdf.line(x+arrowSize, A.y+arrowSize, x, A.y);
      pdf.line(x-arrowSize, B.y-arrowSize, x, B.y);
      pdf.line(x+arrowSize, B.y-arrowSize, x, B.y);
      
      // Texto en mm
      const distMM = Math.abs(B.y - A.y) / step * scaleCM * 10;
      pdf.saveGraphicsState();
      pdf.text(distMM.toFixed(0), x - 2, (A.y + B.y) / 2, 'left', 90);
      pdf.restoreGraphicsState();
    }
  });

  // textos
  textos.forEach(txt=>{
    pdf.setFontSize(txt.fontSize * 0.75);
    pdf.text(txt.texto, startX + (txt.x / parseInt(canvas.style.width)) * (cols-1) * step, 
                     startY + (txt.y / parseInt(canvas.style.height)) * (rows-1) * step);
  });

  pdf.save('dibujo-planos.pdf');
}

// Controles
document.getElementById('cols').addEventListener('input',e=>{ 
  cols=parseInt(e.target.value); 
  document.getElementById('colsLabel').textContent=cols; 
  document.getElementById('colsInput').value=cols;
  rebuildPoints(); drawGrid(); 
});

document.getElementById('colsInput').addEventListener('input',e=>{ 
  let newCols = parseInt(e.target.value);
  if (newCols >= 8 && newCols <= 48) {
    cols = newCols;
    document.getElementById('cols').value = cols;
    document.getElementById('colsLabel').textContent=cols; 
    rebuildPoints(); drawGrid();
  }
});

document.getElementById('rows').addEventListener('input',e=>{ 
  rows=parseInt(e.target.value); 
  document.getElementById('rowsLabel').textContent=rows; 
  document.getElementById('rowsInput').value=rows;
  rebuildPoints(); drawGrid(); 
});

document.getElementById('rowsInput').addEventListener('input',e=>{ 
  let newRows = parseInt(e.target.value);
  if (newRows >= 8 && newRows <= 48) {
    rows = newRows;
    document.getElementById('rows').value = rows;
    document.getElementById('rowsLabel').textContent=rows; 
    rebuildPoints(); drawGrid();
  }
});

document.getElementById('dotSize').addEventListener('input',e=>{ dotSize=parseInt(e.target.value); document.getElementById('dotLabel').textContent=dotSize; drawGrid(); });
document.getElementById('fontSize').addEventListener('change',e=>{ currentFontSize=parseInt(e.target.value); });

document.getElementById('toggleCota').addEventListener('click',()=>{ 
  cotaMode=!cotaMode; 
  eraseMode = false;
  textMode = false;
  lastIdx = null;
  document.getElementById('toggleCota').textContent='Modo cota: '+(cotaMode?'ON':'OFF'); 
  document.getElementById('toggleEraser').textContent='Modo borrado: OFF';
  document.getElementById('toggleText').textContent='Modo texto: OFF';
  canvas.style.cursor = 'default';
  drawGrid();
});

document.getElementById('toggleEraser').addEventListener('click',()=>{ 
  eraseMode=!eraseMode; 
  cotaMode = false;
  textMode = false;
  lastIdx = null;
  document.getElementById('toggleEraser').textContent='Modo borrado: '+(eraseMode?'ON':'OFF'); 
  document.getElementById('toggleCota').textContent='Modo cota: OFF';
  document.getElementById('toggleText').textContent='Modo texto: OFF';
  canvas.style.cursor = eraseMode ? 'url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\' width=\'24\' height=\'24\' viewBox=\'0 0 24 24\'><circle cx=\'12\' cy=\'12\' r=\'10\' fill=\'%23dc3545\' opacity=\'0.7\'/><path d=\'M7 7l10 10M7 17L17 7\' stroke=\'white\' stroke-width=\'2\'/></svg>") 12 12, auto' : 'default';
  drawGrid();
});

document.getElementById('toggleText').addEventListener('click',()=>{ 
  textMode=!textMode; 
  cotaMode = false;
  eraseMode = false;
  lastIdx = null;
  document.getElementById('toggleText').textContent='Modo texto: '+(textMode?'ON':'OFF'); 
  document.getElementById('toggleCota').textContent='Modo cota: OFF';
  document.getElementById('toggleEraser').textContent='Modo borrado: OFF';
  canvas.style.cursor = textMode ? 'text' : 'default';
  drawGrid();
});

document.getElementById('undo').addEventListener('click', undo);
document.getElementById('redo').addEventListener('click', redo);
document.getElementById('clear').addEventListener('click',()=>{ 
  if(confirm('¿Borrar todo?')){ 
    saveState();
    lines=[];
    cotas=[];
    textos=[];
    lastIdx = null;
    drawGrid(); 
  } 
});

document.getElementById('scaleSelect').addEventListener('change',e=>{
  scaleCM=parseFloat(e.target.value);
  rebuildPoints(); drawGrid();
});

document.getElementById('saveProject').addEventListener('click', saveProject);
document.getElementById('loadProject').addEventListener('click', loadProject);
fileInput.addEventListener('change', handleProjectFile);

document.getElementById('download').addEventListener('click', exportToPDF);
document.getElementById('exportDXF').addEventListener('click', exportToDXF);

function init(){ 
  fixDPI(); 
  rebuildPoints(); 
  drawGrid(); 
  saveState();
  document.getElementById('redo').disabled = true;
}
window.addEventListener('resize',init);
init();
</script>
</body>
</html>